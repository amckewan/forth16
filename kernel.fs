\ Forth16 Kernel

CC

HOST DEFINITIONS HEX

( Memory map)
FORTH   F000 CONSTANT R0
        E000 CONSTANT S0
        0010 CONSTANT 'COLD

0 ORG  HOST ASSEMBLER
    R0 T LD   R ST   S0 T LD   S ST   'COLD T LD   EXECUTE

10 ORG   FFFF , ( xt of startup word)

20 ORG

30 uCODE DUP    31 uCODE DROP   32 uCODE SWAP   33 uCODE OVER
34 uCODE ROT    35 uCODE NIP    36 uCODE ?DUP   37 uCODE PICK
38 uCODE >R     39 uCODE R>     3A uCODE R@

LABEL <VARIABLE>  1 ,
: CREATE     TCREATE  <VARIABLE> , ;
: VARIABLE   CREATE  0 , ;

LABEL <CONSTANT>   2 ,
: CONSTANT ( n)   TCREATE  <CONSTANT> ,  , ;

LABEL <COLON>   2 ,
: :   TCREATE  <COLON> ,  ] ;

: (;CODE)  R>

LABEL <DOES>  4 ,
: DOES>

\ DOES> AFTER KERNEL?
: (;CODE)   R> LAST @ CFA ! ;
: ;CODE   COMPILE (;CODE)  ASSEMBLER ; IMMEDIATE
HERE ( DOES> ) 4 ,
: DOES>   COMPILE (;CODE)  9 C, LITERAL , ( call DOES> ) ALIGN ; IMMEDIATE

HERE 2 , ( : runtime )
: :   TCREATE  LITERAL ,  ] ;

1234 CONSTANT FOOBAR

: LIT, ( n)  DPL @ 0< IF  DROP  ELSE  SWAP [COMPILE] LITERAL  THEN
   [COMPILE] LITERAL ;

: 

\ CREATE A NULL WORD THAT IS FOUND?

: INTERPRET   BEGIN  BL WORD  DUP C@ WHILE  -FIND
   IF    DROP NUMBER  DPL @ 0< IF DROP THEN
         STATE @ IF [COMPILE] LITERAL THEN
   ELSE  IMMED? IF EXECUTE ELSE , THEN
   THEN

\ Simpler, same as F83, looks like pF too
: -FIND ( str - str 0 | cfa nfa f)
   ( TODO ) 0 ;
: -'   BL WORD -FIND ;

VARIABLE 'NUMBER 0 ,
VARIABLE DPL
: (NUMBER) ( str - d f)   ( TODO ) DROP 0 0 1 ;
: NUMBER ( str -- n)   \ `NUMBER @ EXECUTE 
   -1 DPL !  (NUMBER)  0= ABORT" ?"  'NUMBER 2+ ! ;


: INTERPRET   BEGIN  -' IF  NUMBER  ELSE  DROP
      EXECUTE  DEPTH 0< ABORT" Stack!"  THEN AGAIN ;

: [  R> DROP ; IMMEDIATE
: ]  -1 STATE !  BEGIN  -' IF  NUMBER  [COMPILE] LITERAL
      DPL @ 0< NOT IF  'NUMBER 2+ @ [COMPILE] LITERAL  THEN
   ELSE ( cfa nfa) C@ $ 40 AND IF  EXECUTE  ELSE  ,  THEN
   THEN AGAIN ;

: QUIT   0 BLK !  0 STATE !
   BEGIN  R0 @ R!  ( STATUS)  QUERY  INTERPRET
     STATE @ NOT IF ." ok" THEN   AGAIN ;
: ABORT   S0 @ S!   QUIT ;

' ABORT 'COLD T!

\  CODE 1+   1 #  +  NEXT
\  CODE 1-   1 #  -  NEXT
\  CODE 2+   2 #  +  NEXT
\  CODE 2-   2 #  -  NEXT
\  CODE 2*   1 # LSHIFT  NEXT
\  CODE 2/   1 # ARSHIFT  NEXT

\  60 uCODE @      61 uCODE !      62 uCODE +!

\  CODE BYE   0 # 0 # BIOS
\  CODE TYPE ( a n)   1 # BIOS  NEXT
\  CODE ACCEPT ( a n -- n2)   2 # BIOS  NEXT

\  CODE BIOS ( ... n -- ...)  BIOS  NEXT
\  : BYE  0 BIOS ;
\  : TYPE  1 BIOS ;
\  : ACCEPT  2 BIOS ;
\  : BIOS CREATE C, ;CODE  DUP  W LD  2+  C@  NEXT
\  0 BIOS BYE  1 BIOS TYPE  2 BIOS ACCEPT
